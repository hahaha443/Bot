import os
import time
import asyncio
from datetime import datetime, date, timedelta
import requests
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup

# C·∫•u h√¨nh
CONFIG = {
    "TELEGRAM_BOT_TOKEN": "7721369545:AAFQ5jnc5qgrJvhLxbNrtYx-SwAgSGKXDHo",
    "MAIN_ADMIN_ID": "6748479692",
    "ADMIN_USERNAME": "hahahe6",
    "LIKE_FF_API_NORMAL": "https://phucios1403.x10.mx/likeff/likefree3.php?uid={}&key=phucesign1403500k",
    "LIKE_FF_API_VIP": "https://phucios1403.x10.mx/likeff/likefree3_vip.php?uid={}&key=phucesign1403500k",
    "FILES": {
        "ADMIN_IDS": "admin.txt",  # ƒê√£ x√≥a /storage/emulated/0/Download/
        "GROUP_IDS": "id_box.txt",
        "GROUP_CD_IDS": "id_box_cd.txt",
        "VIP_IDS": "idlike.txt",
        "USER_BUFF": "user_buff_today.txt"
    }
}

# Bi·∫øn to√†n c·ª•c
VIP_BUFF_IDS = []
BOT_ENABLED = True
last_midnight = None
last_cleanup_date = None

# H√†m g·ª≠i th√¥ng b√°o l·ªói cho admin
async def notify_admin(app, message):
    try:
        if app:
            await app.bot.send_message(chat_id=CONFIG["MAIN_ADMIN_ID"], text=f"üö® *L·ªñI BOT: {message}*", parse_mode="Markdown")
    except Exception as e:
        print(f"Error notifying admin: {e}")

# H√†m g·ª≠i tin nh·∫Øn
async def send_simple_msg(update: Update, context: ContextTypes.DEFAULT_TYPE, text: str, reply_markup=None):
    try:
        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode="Markdown")
        return True
    except Exception as e:
        print(f"Error sending message: {e}")
        await notify_admin(context.application, f"L·ªói g·ª≠i tin nh·∫Øn: {e}")
        return False

# Load VIP v√† x√≥a ID h·∫øt h·∫°n
def load_vip_buff_ids():
    global VIP_BUFF_IDS
    try:
        vip_ids = {}
        if not os.path.exists(CONFIG["FILES"]["VIP_IDS"]):
            print(f"{CONFIG['FILES']['VIP_IDS']} does not exist")
            VIP_BUFF_IDS = []
            return []
        with open(CONFIG["FILES"]["VIP_IDS"], "r") as f:
            lines = f.readlines()
        valid_lines = []
        for line in lines:
            parts = line.strip().split()
            if len(parts) != 2 or not parts[0].isdigit() or not parts[1].isdigit():
                continue
            uid = parts[0]
            expire = int(parts[1])
            if expire > int(time.time()):
                vip_ids[uid] = expire
                valid_lines.append(line)
        with open(CONFIG["FILES"]["VIP_IDS"], "w") as f:
            f.writelines(valid_lines)
        VIP_BUFF_IDS = list(vip_ids.keys())
        return VIP_BUFF_IDS
    except Exception as e:
        print(f"Error loading VIP IDs: {e}")
        VIP_BUFF_IDS = []
        return []

# X√≥a file user_buff_today.txt khi ng√†y m·ªõi
def cleanup_if_new_day():
    global last_cleanup_date
    today = date.today()
    if last_cleanup_date != today:
        try:
            if os.path.exists(CONFIG["FILES"]["USER_BUFF"]):
                os.remove(CONFIG["FILES"]["USER_BUFF"])
                print(f"Cleaned up {CONFIG['FILES']['USER_BUFF']}")
            last_cleanup_date = today
        except Exception as e:
            print(f"Error cleaning up user_buff_today: {e}")

# Ki·ªÉm tra user ƒë√£ buff h√¥m nay ch∆∞a
def has_user_buffed_today(user_id: str) -> bool:
    try:
        cleanup_if_new_day()
        if not os.path.exists(CONFIG["FILES"]["USER_BUFF"]): 
            return False
        with open(CONFIG["FILES"]["USER_BUFF"], "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2 and parts[0] == user_id and parts[1] == str(date.today()):
                    return True
        return False
    except Exception as e:
        print(f"Error checking user buff status: {e}")
        return False

def mark_user_buffed(user_id: str):
    try:
        today = str(date.today())
        with open(CONFIG["FILES"]["USER_BUFF"], "a") as f:
            f.write(f"{user_id} {today}\n")
    except Exception as e:
        print(f"Error marking user buffed: {e}")

# Load danh s√°ch nh√≥m
def load_allowed_groups():
    try:
        allowed_groups = {}
        if not os.path.exists(CONFIG["FILES"]["GROUP_IDS"]):
            print(f"{CONFIG['FILES']['GROUP_IDS']} does not exist")
            return {}
        with open(CONFIG["FILES"]["GROUP_IDS"], "r") as f:
            for line in f:
                parts = line.strip().split(maxsplit=1)
                if len(parts) == 2 and parts[1].startswith("-"):
                    name, group_id = parts
                    allowed_groups[group_id] = name
        return allowed_groups
    except Exception as e:
        print(f"Error loading allowed groups: {e}")
        return {}

def load_allowed_cd_groups():
    try:
        allowed_cd = {}
        if not os.path.exists(CONFIG["FILES"]["GROUP_CD_IDS"]):
            print(f"{CONFIG['FILES']['GROUP_CD_IDS']} does not exist")
            return {}
        with open(CONFIG["FILES"]["GROUP_CD_IDS"], "r") as f:
            for line in f:
                parts = line.strip().split(maxsplit=2)
                if len(parts) == 3 and parts[1].startswith("-") and parts[2].isdigit():
                    name, group_id, cd_id = parts
                    if group_id not in allowed_cd:
                        allowed_cd[group_id] = {}
                    allowed_cd[group_id][cd_id] = name
        return allowed_cd
    except Exception as e:
        print(f"Error loading allowed CD groups: {e}")
        return {}

# Ki·ªÉm tra nh√≥m ƒë∆∞·ª£c ph√©p
def is_group_allowed(chat_id: str) -> bool:
    if not chat_id.startswith("-"):
        return True
    allowed = load_allowed_groups()
    cd_allowed = load_allowed_cd_groups()
    if chat_id in allowed or chat_id in cd_allowed:
        return True
    return False

# Ki·ªÉm tra admin
def is_main_admin(user_id): 
    return str(user_id) == CONFIG["MAIN_ADMIN_ID"]

def is_admin(user_id): 
    try:
        if is_main_admin(user_id): 
            return True
        if not os.path.exists(CONFIG["FILES"]["ADMIN_IDS"]): 
            print(f"{CONFIG['FILES']['ADMIN_IDS']} does not exist in is_admin")
            return False
        with open(CONFIG["FILES"]["ADMIN_IDS"], "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2 and parts[1].isdigit() and str(parts[1]) == user_id:
                    return True
        return False
    except Exception as e:
        print(f"Error checking admin status: {e}")
        return False

# Ki·ªÉm tra quy·ªÅn
async def check_permission(update: Update, context: ContextTypes.DEFAULT_TYPE, is_admin_required=False, is_main_admin_required=False):
    user_id = str(update.effective_user.id)
    if not is_admin_required and not is_main_admin_required:
        return True
    if is_main_admin_required and not is_main_admin(user_id): 
        await send_simple_msg(update, context, "*üö® B·∫°n kh√¥ng c√≥ quy·ªÅn admin ch√≠nh!*")
        print(f"Permission denied for user {user_id}: Not main admin")
        return False
    if is_admin_required and not is_admin(user_id): 
        await send_simple_msg(update, context, "*üö® B·∫°n kh√¥ng c√≥ quy·ªÅn admin!*")
        print(f"Permission denied for user {user_id}: Not admin")
        return False
    return True

# Ki·ªÉm tra tr·∫°ng th√°i bot
async def check_bot_enabled(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = str(update.effective_user.id)
    if not BOT_ENABLED and not is_admin(user_id):
        await send_simple_msg(update, context, "*üåü Bot ƒëang b·∫£o tr√¨! Vui l√≤ng th·ª≠ l·∫°i sau.*")
        print(f"Bot disabled for user {user_id}")
        return False
    return True

# Load/save VIP
def load_vip_ids():
    try:
        if not os.path.exists(CONFIG["FILES"]["VIP_IDS"]): 
            print(f"{CONFIG['FILES']['VIP_IDS']} does not exist in load_vip_ids")
            return {}
        vip_ids = {}
        with open(CONFIG["FILES"]["VIP_IDS"], "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2 and parts[0].isdigit() and parts[1].isdigit():
                    vip_ids[parts[0]] = {"expire": int(parts[1])}
        return vip_ids
    except Exception as e:
        print(f"Error loading VIP IDs: {e}")
        return {}

def save_vip_ids(vip_ids):
    try:
        with open(CONFIG["FILES"]["VIP_IDS"], "w") as f:
            content = "\n".join(f"{uid} {info['expire']}" for uid, info in vip_ids.items())
            f.write(content + "\n")
    except Exception as e:
        print(f"Error saving VIP IDs: {e}")

def save_admin_ids(admin_ids):
    try:
        with open(CONFIG["FILES"]["ADMIN_IDS"], "w") as f:
            for name, id_ in admin_ids.items():
                if name != "main_admin":
                    f.write(f"{name} {id_}\n")
    except Exception as e:
        print(f"Error saving admin IDs: {e}")

# Ki·ªÉm tra API
async def check_api_status():
    try:
        response = requests.get(CONFIG["LIKE_FF_API_NORMAL"].format("123456789"), timeout=10)
        return response.status_code == 200
    except Exception:
        return False

# API functions
async def api_request(url, uid):
    max_retries = 3
    start_time = time.time()
    for attempt in range(max_retries):
        try:
            response = requests.get(url.format(uid), timeout=30)
            response.raise_for_status()
            try:
                data = response.json()
                api_time = round(time.time() - start_time, 4)
                return data, api_time
            except ValueError:
                return None, None
        except requests.RequestException:
            if attempt < max_retries - 1:
                await asyncio.sleep(2)
            continue
    return None, None

async def buff_like(uid, is_vip=False):
    url = CONFIG["LIKE_FF_API_VIP"] if is_vip else CONFIG["LIKE_FF_API_NORMAL"]
    data, api_time = await api_request(url, uid)
    if is_vip and not data:
        data, api_time = await api_request(CONFIG["LIKE_FF_API_NORMAL"], uid)
    return _parse_buff_result_full(data, api_time) if data else {"success": False, "message": "L·ªói k·∫øt n·ªëi API", "api_time": api_time or 0}

def _parse_buff_result_full(data, api_time):
    if data.get("status") == "success":
        message = data.get("message", "").lower()
        likes_given = data.get("LikesGivenByAPI", 0)
        likes_before = data.get("LikesbeforeCommand", 0)
        likes_after = data.get("LikesafterCommand", 0)
        player_name = data.get("PlayerNickname", None)
        if not player_name:
            player_name = "Kh√¥ng r√µ"
        if "max like h√¥m nay" in message or likes_given == 0:
            return {
                "success": True,
                "likes_given": 0,
                "likes_before": likes_before,
                "likes_after": likes_after,
                "player_name": player_name,
                "message": "ƒê√£ buff like h√¥m nay r·ªìi!",
                "api_time": api_time
            }
        return {
            "success": True,
            "likes_given": likes_given,
            "likes_before": likes_before,
            "likes_after": likes_after,
            "player_name": player_name,
            "message": message,
            "api_time": api_time
        }
    return {"success": False, "message": "L·ªói API", "api_time": api_time}

# G·ª≠i b√°o c√°o ƒë·∫øn nh√≥m
async def send_to_all_allowed_groups(app, message: str):
    try:
        normal_groups = load_allowed_groups()
        cd_groups = load_allowed_cd_groups()
        
        tasks = []
        for group_id in normal_groups:
            tasks.append(app.bot.send_message(
                chat_id=group_id, 
                text=message,
                parse_mode="Markdown"
            ))
        
        for group_id, topics in cd_groups.items():
            for cd_id in topics:
                tasks.append(app.bot.send_message(
                    chat_id=group_id, 
                    message_thread_id=int(cd_id), 
                    text=f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® AUTO BUFF VIP - #{cd_id} ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n{message}",
                    parse_mode="Markdown"
                ))
        
        await asyncio.gather(*tasks, return_exceptions=True)
    except Exception as e:
        print(f"Error sending to groups: {e}")
        await notify_admin(app, "L·ªói g·ª≠i b√°o c√°o ƒë·∫øn nh√≥m")

# Auto buff
async def perform_auto_buff(app, buff_type="KH·ªûI ƒê·ªòNG"):
    if not await check_api_status():
        await notify_admin(app, "API kh√¥ng ho·∫°t ƒë·ªông, auto buff b·ªã b·ªè qua")
        return
    
    cleanup_if_new_day()
    load_vip_buff_ids()
    all_buff_ids = VIP_BUFF_IDS[:50]
    
    if not all_buff_ids:
        await notify_admin(app, "Kh√¥ng t√¨m th·∫•y ID VIP n√†o ƒë·ªÉ buff")
        return
    
    results = []
    success_count = 0
    sem = asyncio.Semaphore(3)
    
    async def buff_with_limit(uid):
        async with sem:
            try:
                result = await buff_like(uid, True)
                return uid, result
            except Exception:
                return uid, {"success": False, "message": "L·ªói x·ª≠ l√Ω", "api_time": 0}
    
    tasks = [buff_with_limit(uid) for uid in all_buff_ids]
    try:
        results = await asyncio.gather(*tasks, return_exceptions=True)
    except Exception:
        await notify_admin(app, "L·ªói x·ª≠ l√Ω auto buff")
        return
    
    for uid, result in results:
        if isinstance(result, Exception):
            continue
        if result["success"]: 
            success_count += 1
    
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    buff_message = f"*‚ïê‚ïê‚ïê‚ú® AUTO BUFF VIP FREE FIRE ‚ú®‚ïê‚ïê‚ïê*\n" \
                   f"*üöÄ Lo·∫°i: {buff_type} | Th√†nh C√¥ng: {success_count}/{len(all_buff_ids)}*\n\n" \
                   f"*üíé DANH S√ÅCH BUFF VIP üíé*\n"
    
    for uid, result in results:
        if isinstance(result, Exception):
            buff_message += f"‚û§ ID: *{uid}*\n" \
                           f"‚ùå Tr·∫°ng Th√°i: *L·ªói x·ª≠ l√Ω*\n" \
                           f"‚ö° T·ªëc ƒê·ªô: *0s*\n" \
                           f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
            continue
        if result["success"] and result["likes_given"] > 0:
            player_name = result["player_name"]
            likes_given = result["likes_given"]
            likes_before = result["likes_before"]
            likes_after = result["likes_after"]
            api_time = result["api_time"]
            buff_message += f"‚û§ T√™n: *{player_name}*\n" \
                           f"‚û§ ID: *{uid}*\n" \
                           f"üíñ Like ƒê√£ G·ª≠i: *{likes_given} likes*\n" \
                           f"üìâ Like Tr∆∞·ªõc: *{likes_before}*\n" \
                           f"üìà Like Sau: *{likes_after}*\n" \
                           f"‚ö° T·ªëc ƒê·ªô: *{api_time}s*\n" \
                           f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
        else:
            status = "‚úÖ" if result["success"] else "‚ùå"
            msg = result.get('message', 'L·ªói API')
            api_time = result.get('api_time', 0)
            buff_message += f"‚û§ ID: *{uid}*\n" \
                           f"{status} Tr·∫°ng Th√°i: *{msg}*\n" \
                           f"‚ö° T·ªëc ƒê·ªô: *{api_time}s*\n" \
                           f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    
    buff_message += f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN D·ªäCH V·ª§ ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
                   f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                   f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                   f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    
    try:
        await send_to_all_allowed_groups(app, buff_message)
        await notify_admin(app, f"{buff_type} AUTO BUFF HO√ÄN T·∫§T: {success_count}/{len(all_buff_ids)}")
    except Exception:
        await notify_admin(app, "L·ªói g·ª≠i b√°o c√°o auto buff")

# Auto buff loop
async def auto_buff_loop(app):
    global last_midnight
    while True:
        try:
            now = datetime.now()
            today_midnight = now.replace(hour=0, minute=0, second=0, microsecond=0)
            next_midnight = today_midnight + timedelta(days=1)
            
            if last_midnight != today_midnight:
                last_midnight = today_midnight
                await perform_auto_buff(app, "00:00")
            
            seconds_until_next_midnight = (next_midnight - now).total_seconds()
            if seconds_until_next_midnight < 0:
                seconds_until_next_midnight += 24 * 3600
            await asyncio.sleep(seconds_until_next_midnight)
        except Exception:
            await notify_admin(app, "L·ªói trong auto buff")
            await asyncio.sleep(60)

# Reload VIP ƒë·ªãnh k·ª≥
async def reload_vip_periodically(app):
    while True:
        try:
            load_vip_buff_ids()
        except Exception:
            await notify_admin(app, "L·ªói reload danh s√°ch VIP")
        await asyncio.sleep(600)

# L·ªánh /on
async def on_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global BOT_ENABLED
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if BOT_ENABLED:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚úÖ Bot ƒë√£ ƒëang *B·∫¨T*! Kh√¥ng c·∫ßn b·∫≠t l·∫°i.\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    else:
        BOT_ENABLED = True
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® B·∫¨T BOT TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"üöÄ Bot ƒë√£ ƒë∆∞·ª£c *B·∫¨T* v√† s·∫µn s√†ng ho·∫°t ƒë·ªông!\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await notify_admin(context.application, "Bot ƒë√£ ƒë∆∞·ª£c b·∫≠t")
    await send_simple_msg(update, context, message)

# L·ªánh /off
async def off_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    global BOT_ENABLED
    if not await check_permission(update, context, is_main_admin_required=True): return
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if not BOT_ENABLED:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå Bot ƒë√£ ƒëang *T·∫ÆT*! Kh√¥ng c·∫ßn t·∫Øt l·∫°i.\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    else:
        BOT_ENABLED = False
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® T·∫ÆT BOT TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"üõë Bot ƒë√£ ƒë∆∞·ª£c *T·∫ÆT*. C√°c l·ªánh s·∫Ω kh√¥ng ho·∫°t ƒë·ªông (tr·ª´ admin).\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await notify_admin(context.application, "Bot ƒë√£ ƒë∆∞·ª£c t·∫Øt")
    await send_simple_msg(update, context, message)

# L·ªánh /admin
async def admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_admin_required=True): return
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® MENU D√ÄNH CHO ADMIN ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
              f"*üí´ L·ªánh Admin *\n" \
              f"‚Ä¢ `/likeffvip <uid> <day>` - Th√™m ID VIP\n" \
              f"‚Ä¢ `/likefflai` - TƒÉng like l·∫°i cho t·∫•t c·∫£ ID VIP\n" \
              f"‚Ä¢ `/listvip` - Xem danh s√°ch ID VIP\n" \
              f"‚Ä¢ `/status` - Ki·ªÉm tra tr·∫°ng th√°i bot\n\n" \
              f"*üí´ L·ªánh Admin Ch√≠nh *\n" \
              f"‚Ä¢ `/yes <t√™n> <group_id>` - Cho ph√©p nh√≥m d√πng bot\n" \
              f"‚Ä¢ `/no <t√™n> <group_id>` - X√≥a nh√≥m kh·ªèi danh s√°ch\n" \
              f"‚Ä¢ `/yes1 <t√™n> <group_id> <cd>` - Cho ph√©p nh√≥m v·ªõi ch·ªß ƒë·ªÅ\n" \
              f"‚Ä¢ `/no1 <t√™n> <group_id> <cd>` - X√≥a nh√≥m ch·ªß ƒë·ªÅ\n" \
              f"‚Ä¢ `/on` - B·∫≠t bot\n" \
              f"‚Ä¢ `/off` - T·∫Øt bot\n" \
              f"‚Ä¢ `/addadmin <t√™n> <id>` - Th√™m admin\n" \
              f"‚Ä¢ `/deladmin <t√™n>` - X√≥a admin\n" \
              f"‚Ä¢ `/list_idad` - Xem danh s√°ch admin\n" \
              f"‚Ä¢ `/listgroups` - Xem danh s√°ch nh√≥m\n" \
              f"‚Ä¢ `/clearfiles` - X√≥a c√°c file c·∫•u h√¨nh bot\n\n" \
              f"*üí´ L·ªánh Chung *\n" \
              f"‚Ä¢ `/buy` - Xem b·∫£ng gi√° VIP\n" \
              f"‚Ä¢ `/like <uid>` - TƒÉng like mi·ªÖn ph√≠\n" \
              f"‚Ä¢ `/menuff` - Xem menu l·ªánh\n\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
              f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
              f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, message)

# L·ªánh /status
async def status_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_admin_required=True): return
    status = "B·∫¨T" if BOT_ENABLED else "T·∫ÆT"
    vip_count = len(VIP_BUFF_IDS)
    api_status = "Ho·∫°t ƒë·ªông" if await check_api_status() else "Kh√¥ng ho·∫°t ƒë·ªông"
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TR·∫†NG TH√ÅI BOT FREE FIRE ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
              f"üîÑ Tr·∫°ng Th√°i: *{status}*\n" \
              f"üíé S·ªë ID VIP: *{vip_count}*\n" \
              f"üåê API: *{api_status}*\n" \
              f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
              f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, message)

# L·ªánh /like
async def like_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    chat_id = str(update.effective_chat.id)
    if not is_group_allowed(chat_id):
        await send_simple_msg(update, context, "*üåü Nh√≥m ch∆∞a ƒë∆∞·ª£c c·∫•p ph√©p s·ª≠ d·ª•ng bot!*")
        return
    user_id = str(update.effective_user.id)
    
    if not is_main_admin(user_id) and has_user_buffed_today(user_id):
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO TƒÇNG LIKE ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå *ƒê√£ buff like h√¥m nay r·ªìi!*\n" \
                  f"üìå Vui l√≤ng th·ª≠ l·∫°i sau 00:00 ho·∫∑c mua g√≥i VIP t·∫°i /buy\n" \
                  f"‚ö° T·ªëc ƒê·ªô API: *0 gi√¢y*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
        return
    
    args = context.args
    if len(args) != 1 or not args[0].isdigit():
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /like <uid>*")
        return
    
    uid = args[0]
    msg = await update.message.reply_text(f"ƒêang buff like cho iD: *{uid}*", parse_mode="Markdown")
    
    start_time = time.time()
    result = await buff_like(uid, False)
    api_time = result.get("api_time", round(time.time() - start_time, 4))
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    if result["success"]:
        likes_given = result["likes_given"]
        if likes_given > 0:
            player_name = result["player_name"]
            likes_before = result["likes_before"]
            likes_after = result["likes_after"]
            likes_added = likes_after - likes_before
            report = f"*‚ïê‚ïê‚ïê‚ú® B√ÅO C√ÅO TƒÇNG LIKE FREE FIRE ‚ú®‚ïê‚ïê‚ïê*\n\n" \
                     f"*üéÆ Th√¥ng Tin Ng∆∞·ªùi Ch∆°i*\n" \
                     f"‚û§ T√™n: *{player_name}*\n" \
                     f"‚û§ ID: *{uid}*\n\n" \
                     f"*üî• K·∫øt Qu·∫£ Buff Like üî•*\n" \
                     f"‚úÖ Tr·∫°ng Th√°i: *TH√ÄNH C√îNG*\n" \
                     f"üíñ Like ƒê√£ G·ª≠i: *{likes_given} likes*\n" \
                     f"üìâ Like Tr∆∞·ªõc: *{likes_before}*\n" \
                     f"üìà Like Sau: *{likes_after}*\n" \
                     f"‚Üó TƒÉng Th√™m: *{likes_added} likes*\n\n" \
                     f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN D·ªäCH V·ª§ ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
                     f"‚ö° T·ªëc ƒê·ªô API: *{api_time} gi√¢y*\n" \
                     f"ü™ô Lo·∫°i: *Th∆∞·ªùng (Free)*\n" \
                     f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                     f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                     f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            if not is_main_admin(user_id):
                mark_user_buffed(user_id)
        else:
            report = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO TƒÇNG LIKE ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                     f"‚ùå *ƒê√£ buff like h√¥m nay r·ªìi!*\n" \
                     f"üìå Vui l√≤ng th·ª≠ l·∫°i sau 00:00 ho·∫∑c mua g√≥i VIP t·∫°i /buy\n" \
                     f"‚ö° T·ªëc ƒê·ªô API: *{api_time} gi√¢y*\n" \
                     f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                     f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                     f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    else:
        report = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® B√ÅO C√ÅO L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                 f"‚û§ ID: *{uid}*\n" \
                 f"‚ùå L·ªói: *{result.get('message', 'L·ªói API')}*\n" \
                 f"‚ö° T·ªëc ƒê·ªô API: *{api_time} gi√¢y*\n" \
                 f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                 f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                 f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    
    await msg.edit_text(report, parse_mode="Markdown")

# L·ªánh /buy
async def buy_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    chat_id = str(update.effective_chat.id)
    if not is_group_allowed(chat_id):
        await send_simple_msg(update, context, "*üåü Nh√≥m ch∆∞a ƒë∆∞·ª£c c·∫•p ph√©p s·ª≠ d·ª•ng bot!*")
        return
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® B·∫¢NG GI√Å VIP LIKE FF ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
              f"*üì¶ G√ìI NG·∫ÆN H·∫†N*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïêüåü‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
              f"üìå 1 Ng√†y    ‚Äî *10.000ƒë*\n" \
              f"üìå 3 Ng√†y    ‚Äî *30.000ƒë*\n" \
              f"üìå 7 Ng√†y    ‚Äî *50.000ƒë*\n" \
              f"üìå 10 Ng√†y   ‚Äî *90.000ƒë*\n" \
              f"üìå 30 Ng√†y   ‚Äî *170.000ƒë*\n\n" \
              f"*üíñ CHI TI·∫æT G√ìI LIKES*\n" \
              f"üíé 50K / 7 ng√†y ‚Äî *700 Likes*\n" \
              f"üíé 60K / 14 ng√†y ‚Äî *1400 Likes*\n" \
              f"üíé 170K / 30 ng√†y ‚Äî *3000 Likes*\n\n" \
              f"*‚ö° HO·∫†T ƒê·ªòNG ·ªîN ƒê·ªäNH*\n" \
              f"üíé *Gi√° t·ªët ‚Äì Uy t√≠n ‚Äì Ch·∫•t l∆∞·ª£ng*\n" \
              f"üîí *B·∫£o m·∫≠t & an to√†n tuy·ªát ƒë·ªëi*\n\n" \
              f"*üìå D·ªãch v·ª• thu√™ BOT Like FF t·ª± ƒë·ªông*\n" \
              f"‚úîÔ∏è Ph√π h·ª£p cho anh em b·∫≠n r·ªôn\n" \
              f"‚úîÔ∏è Auto 100 likes m·ªói ng√†y ‚úÖ\n\n" \
              f"*üëë Li√™n h·ªá: @{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    keyboard = [
        [
            InlineKeyboardButton("G√≥i 1 Ng√†y (10K)", callback_data="buy_1day"),
            InlineKeyboardButton("G√≥i 3 Ng√†y (30K)", callback_data="buy_3day")
        ],
        [
            InlineKeyboardButton("G√≥i 7 Ng√†y (50K)", callback_data="buy_7day"),
            InlineKeyboardButton("G√≥i 10 Ng√†y (90K)", callback_data="buy_10day")
        ],
        [
            InlineKeyboardButton("G√≥i 30 Ng√†y (170K)", callback_data="buy_30day"),
            InlineKeyboardButton("Xem G√≥i Likes", callback_data="vip_likes")
        ],
        [
            InlineKeyboardButton("Li√™n h·ªá Admin", url=f"https://t.me/{CONFIG['ADMIN_USERNAME']}")
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await send_simple_msg(update, context, message, reply_markup)

# L·ªánh /menuff
async def menuff_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    chat_id = str(update.effective_chat.id)
    if not is_group_allowed(chat_id):
        await send_simple_msg(update, context, "*üåü Nh√≥m ch∆∞a ƒë∆∞·ª£c c·∫•p ph√©p s·ª≠ d·ª•ng bot!*")
        return
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® MENU FREE FIRE ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
              f"*üí´ L·ªánh D√†nh Cho Ng∆∞·ªùi D√πng*\n" \
              f"‚Ä¢ `/like <uid>` - TƒÉng like mi·ªÖn ph√≠ (1 l·∫ßn/ng√†y)\n" \
              f"‚Ä¢ `/buy` - Xem b·∫£ng gi√° VIP\n" \
              f"üìå V√≠ d·ª•: `/like 7786937940`\n\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
              f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
              f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, message)

# L·ªánh /likeffvip
async def likeffvip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_admin_required=True): return
    args = context.args
    if len(args) != 2 or not args[0].isdigit() or not args[1].isdigit(): 
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /likeffvip <uid> <day>*")
        return
    uid, days = args[0], int(args[1])
    vip_ids = load_vip_ids()
    expire_time = int(time.time()) + days * 86400
    vip_ids[uid] = {"expire": expire_time}
    save_vip_ids(vip_ids)
    expire_date = datetime.fromtimestamp(expire_time).strftime("%Y-%m-%d %H:%M:%S")
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√äM VIP TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
              f"‚û§ ID: *{uid}*\n" \
              f"‚û§ H·∫øt H·∫°n: *{expire_date}*\n" \
              f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
              f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, message)

# L·ªánh /likefflai
async def likefflai_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_admin_required=True): return
    load_vip_buff_ids()
    if not VIP_BUFF_IDS:
        await send_simple_msg(update, context, "*‚ùå Kh√¥ng t√¨m th·∫•y ID VIP n√†o!*")
        return
    await perform_auto_buff(context.application, "TH·ª¶ C√îNG")

# L·ªánh /listvip
async def listvip_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_admin_required=True): return
    vip_ids = load_vip_ids()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if not vip_ids:
        await send_simple_msg(update, context, "*‚ùå Kh√¥ng c√≥ ID VIP n√†o!*")
        return
    text = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® DANH S√ÅCH ID VIP ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
           f"üíé T·ªïng S·ªë: *{len(vip_ids)} ID*\n"
    for uid, info in vip_ids.items():
        expire_date = datetime.fromtimestamp(info["expire"]).strftime("%Y-%m-%d %H:%M")
        status = "‚úÖ" if info["expire"] > int(time.time()) else "‚ùå"
        text += f"‚û§ ID: *{uid}*\n" \
                f"‚û§ H·∫øt H·∫°n: *{expire_date}*\n" \
                f"‚û§ Tr·∫°ng Th√°i: *{status}*\n" \
                f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    text += f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
            f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
            f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
            f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, text)

# L·ªánh /yes
async def yes_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 2 or not args[1].startswith("-"):
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /yes <t√™n> <group_id>*")
        return
    name, group_id = args
    allowed_groups = load_allowed_groups()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if group_id in allowed_groups:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå Nh√≥m *{group_id}* ƒë√£ ƒë∆∞·ª£c c·∫•p ph√©p v·ªõi t√™n: *{allowed_groups[group_id]}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
        return
    for existing_name in allowed_groups.values():
        if existing_name == name:
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå T√™n *{name}* ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho nh√≥m kh√°c!\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
            return
    try:
        with open(CONFIG["FILES"]["GROUP_IDS"], "a") as f:
            f.write(f"{name} {group_id}\n")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® C·∫§P PH√âP NH√ìM TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚û§ T√™n: *{name}*\n" \
                  f"‚û§ ID: *{group_id}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
    except Exception as e:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói th√™m nh√≥m *{name}* (*{group_id}*): *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /no
async def no_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 2:
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /no <t√™n> <group_id>*")
        return
    name, group_id = args
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        if os.path.exists(CONFIG["FILES"]["GROUP_IDS"]):
            with open(CONFIG["FILES"]["GROUP_IDS"], "r") as f:
                lines = f.readlines()
            with open(CONFIG["FILES"]["GROUP_IDS"], "w") as f:
                for line in lines:
                    parts = line.strip().split(maxsplit=1)
                    if len(parts) == 2 and (parts[0] != name and parts[1] != group_id):
                        f.write(line)
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® X√ìA NH√ìM TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚û§ T√™n: *{name}*\n" \
                      f"‚û§ ID: *{group_id}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
        else:
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m:\n" \
                      f"‚û§ T√™n: *{name}*\n" \
                      f"‚û§ ID: *{group_id}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
    except Exception as e:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói x√≥a nh√≥m *{name}* (*{group_id}*): *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /yes1
async def yes1_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 3 or not args[1].startswith("-") or not args[2].isdigit():
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /yes1 <t√™n> <group_id> <cd>*")
        return
    name, group_id, cd_id = args
    allowed_cd = load_allowed_cd_groups()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if group_id in allowed_cd and cd_id in allowed_cd[group_id]:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå Nh√≥m ch·ªß ƒë·ªÅ *{group_id}* (*{cd_id}*) ƒë√£ ƒë∆∞·ª£c c·∫•p ph√©p v·ªõi t√™n: *{allowed_cd[group_id][cd_id]}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
        return
    for gid, topics in allowed_cd.items():
        for cid, n in topics.items():
            if n == name:
                message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                          f"‚ùå T√™n *{name}* ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng cho nh√≥m *{gid}* (ch·ªß ƒë·ªÅ *{cid}*)!\n" \
                          f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                          f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                          f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
                await send_simple_msg(update, context, message)
                return
    try:
        with open(CONFIG["FILES"]["GROUP_CD_IDS"], "a") as f:
            f.write(f"{name} {group_id} {cd_id}\n")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® C·∫§P PH√âP NH√ìM CH·ª¶ ƒê·ªÄ TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚û§ T√™n: *{name}*\n" \
                  f"‚û§ ID: *{group_id}*\n" \
                  f"‚û§ Ch·ªß ƒê·ªÅ: *{cd_id}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
    except Exception as e:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói th√™m ch·ªß ƒë·ªÅ *{name}* (*{group_id}* *{cd_id}*): *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /no1
async def no1_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 3:
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /no1 <t√™n> <group_id> <cd>*")
        return
    name, group_id, cd_id = args
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        if os.path.exists(CONFIG["FILES"]["GROUP_CD_IDS"]):
            with open(CONFIG["FILES"]["GROUP_CD_IDS"], "r") as f:
                lines = f.readlines()
            with open(CONFIG["FILES"]["GROUP_CD_IDS"], "w") as f:
                for line in lines:
                    parts = line.strip().split(maxsplit=2)
                    if len(parts) == 3 and (parts[0] != name and parts[1] != group_id or parts[2] != cd_id):
                        f.write(line)
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® X√ìA NH√ìM CH·ª¶ ƒê·ªÄ TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚û§ T√™n: *{name}*\n" \
                      f"‚û§ ID: *{group_id}*\n" \
                      f"‚û§ Ch·ªß ƒê·ªÅ: *{cd_id}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
        else:
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå Kh√¥ng t√¨m th·∫•y nh√≥m ch·ªß ƒë·ªÅ:\n" \
                      f"‚û§ T√™n: *{name}*\n" \
                      f"‚û§ ID: *{group_id}*\n" \
                      f"‚û§ Ch·ªß ƒê·ªÅ: *{cd_id}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
    except Exception as e:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói x√≥a ch·ªß ƒë·ªÅ *{name}* (*{group_id}* *{cd_id}*): *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /listgroups
async def listgroups_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    normal_groups = load_allowed_groups()
    cd_groups = load_allowed_cd_groups()
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    text = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® DANH S√ÅCH NH√ìM ƒê∆Ø·ª¢C PH√âP ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
           f"*üíé Nh√≥m Th∆∞·ªùng ({len(normal_groups)})*\n"
    for group_id, name in sorted(normal_groups.items()):
        text += f"‚û§ T√™n: *{name}*\n" \
                f"‚û§ ID: *{group_id}*\n" \
                f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    text += f"*üíé Nh√≥m Ch·ªß ƒê·ªÅ ({sum(len(topics) for topics in cd_groups.values())})*\n"
    for group_id in sorted(cd_groups.keys()):
        for cd_id, name in sorted(cd_groups[group_id].items()):
            text += f"‚û§ T√™n: *{name}*\n" \
                    f"‚û§ ID: *{group_id}*\n" \
                    f"‚û§ Ch·ªß ƒê·ªÅ: *{cd_id}*\n" \
                    f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    text += f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
            f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
            f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
            f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    await send_simple_msg(update, context, text)

# L·ªánh /list_idad
async def list_idad_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): 
        print("Bot disabled or not enabled for /list_idad")
        return
    if not await check_permission(update, context, is_main_admin_required=True): 
        print("Permission denied for /list_idad")
        return
    admin_ids = {"main_admin": int(CONFIG["MAIN_ADMIN_ID"])}
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    file_path = CONFIG["FILES"]["ADMIN_IDS"]
    
    # Ki·ªÉm tra quy·ªÅn truy c·∫≠p file
    if os.path.exists(file_path):
        if not os.access(file_path, os.R_OK):
            print(f"Cannot read {file_path}: Permission denied")
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå Kh√¥ng th·ªÉ ƒë·ªçc file admin.txt: *Quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi*\n" \
                      f"üìå Vui l√≤ng ki·ªÉm tra quy·ªÅn file: chmod 666 {file_path}\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
            return
        try:
            with open(file_path, "r") as f:
                for line in f:
                    parts = line.strip().split()
                    if len(parts) == 2 and parts[1].isdigit():
                        admin_ids[parts[0]] = int(parts[1])
        except Exception as e:
            print(f"Error reading {file_path} in list_idad_command: {e}")
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå L·ªói ƒë·ªçc file admin.txt: *{str(e)}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
            return
    else:
        print(f"{file_path} does not exist in list_idad_command")
    
    text = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® DANH S√ÅCH ADMIN ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
           f"üíé T·ªïng S·ªë: *{len(admin_ids)} Admin*\n"
    for name, id_ in admin_ids.items():
        text += f"‚û§ T√™n: *{name}*\n" \
                f"‚û§ ID: *{id_}*\n" \
                f"‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n"
    text += f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
            f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
            f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
            f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    
    try:
        await send_simple_msg(update, context, text)
    except Exception as e:
        print(f"Error sending list_idad response: {e}")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói g·ª≠i danh s√°ch admin: *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /addadmin
async def add_admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 2 or not args[1].isdigit():
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /addadmin <t√™n> <id>*")
        return
    name, user_id = args[0], int(args[1])
    admin_ids = {"main_admin": int(CONFIG["MAIN_ADMIN_ID"])}
    file_path = CONFIG["FILES"]["ADMIN_IDS"]
    
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2 and parts[1].isdigit():
                    admin_ids[parts[0]] = int(parts[1])
    
    admin_ids[name] = user_id
    try:
        if not os.access(os.path.dirname(file_path) or ".", os.W_OK):
            current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå Kh√¥ng th·ªÉ ghi file admin.txt: *Quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi*\n" \
                      f"üìå Vui l√≤ng ki·ªÉm tra quy·ªÅn th∆∞ m·ª•c: chmod 777 {os.path.dirname(file_path) or '.'}\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
            return
        save_admin_ids(admin_ids)
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√äM ADMIN TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚û§ T√™n: *{name}*\n" \
                  f"‚û§ ID: *{user_id}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
    except Exception as e:
        current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói th√™m admin *{name}* (*{user_id}*): *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /deladmin
async def deladmin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): return
    if not await check_permission(update, context, is_main_admin_required=True): return
    args = context.args
    if len(args) != 1:
        await send_simple_msg(update, context, "*‚ùå Sai c√∫ ph√°p: /deladmin <t√™n>*")
        return
    name = args[0]
    admin_ids = {"main_admin": int(CONFIG["MAIN_ADMIN_ID"])}
    file_path = CONFIG["FILES"]["ADMIN_IDS"]
    
    if os.path.exists(file_path):
        with open(file_path, "r") as f:
            for line in f:
                parts = line.strip().split()
                if len(parts) == 2 and parts[1].isdigit():
                    admin_ids[parts[0]] = int(parts[1])
    
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    if name in admin_ids and name != "main_admin":
        del admin_ids[name]
        try:
            if not os.access(os.path.dirname(file_path) or ".", os.W_OK):
                message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                          f"‚ùå Kh√¥ng th·ªÉ ghi file admin.txt: *Quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi*\n" \
                          f"üìå Vui l√≤ng ki·ªÉm tra quy·ªÅn th∆∞ m·ª•c: chmod 777 {os.path.dirname(file_path) or '.'}\n" \
                          f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                          f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                          f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
                await send_simple_msg(update, context, message)
                return
            save_admin_ids(admin_ids)
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® X√ìA ADMIN TH√ÄNH C√îNG ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚û§ T√™n: *{name}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
        except Exception as e:
            message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                      f"‚ùå L·ªói x√≥a admin *{name}*: *{str(e)}*\n" \
                      f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                      f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                      f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
            await send_simple_msg(update, context, message)
    else:
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® TH√îNG B√ÅO ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå Kh√¥ng t√¨m th·∫•y admin:\n" \
                  f"‚û§ T√™n: *{name}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# L·ªánh /clearfiles
async def clearfiles_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not await check_bot_enabled(update, context): 
        print("Bot disabled or not enabled for /clearfiles")
        return
    if not await check_permission(update, context, is_main_admin_required=True): 
        print("Permission denied for /clearfiles")
        return
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    deleted_files = []
    failed_files = []
    max_retries = 3
    
    # Danh s√°ch file c·∫ßn x√≥a
    files_to_delete = [
        CONFIG["FILES"]["ADMIN_IDS"],
        CONFIG["FILES"]["GROUP_IDS"],
        CONFIG["FILES"]["GROUP_CD_IDS"],
        CONFIG["FILES"]["VIP_IDS"],
        CONFIG["FILES"]["USER_BUFF"]
    ]
    
    # Ki·ªÉm tra quy·ªÅn th∆∞ m·ª•c
    dir_path = os.path.dirname(files_to_delete[0]) or "."
    if not os.access(dir_path, os.W_OK):
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå Kh√¥ng th·ªÉ ghi v√†o th∆∞ m·ª•c: *{dir_path}*\n" \
                  f"üìå Vui l√≤ng c·∫•p quy·ªÅn: chmod 777 {dir_path}\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)
        print(f"Cannot write to {dir_path}: Permission denied")
        return
    
    # Th·ª≠ x√≥a t·ª´ng file
    for file_path in files_to_delete:
        for attempt in range(max_retries):
            try:
                if not os.path.exists(file_path):
                    print(f"File does not exist: {file_path}")
                    break
                if not os.access(file_path, os.W_OK):
                    print(f"Cannot write to {file_path}: Permission denied")
                    failed_files.append((os.path.basename(file_path), "Quy·ªÅn truy c·∫≠p b·ªã t·ª´ ch·ªëi"))
                    break
                os.remove(file_path)
                deleted_files.append(os.path.basename(file_path))
                print(f"Deleted file: {file_path}")
                break
            except Exception as e:
                print(f"Error deleting {file_path} (attempt {attempt + 1}/{max_retries}): {e}")
                if attempt == max_retries - 1:
                    failed_files.append((os.path.basename(file_path), str(e)))
                time.sleep(1)  # Ch·ªù tr∆∞·ªõc khi th·ª≠ l·∫°i
    
    # X√≥a danh s√°ch VIP trong b·ªô nh·ªõ
    global VIP_BUFF_IDS
    VIP_BUFF_IDS = []
    
    # T·∫°o th√¥ng b√°o
    message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® X√ìA FILE C·∫§U H√åNH ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n"
    if deleted_files:
        message += f"‚úÖ ƒê√£ x√≥a c√°c file:\n"
        for file in deleted_files:
            message += f"‚û§ *{file}*\n"
    else:
        message += f"‚ö†Ô∏è Kh√¥ng c√≥ file n√†o ƒë∆∞·ª£c x√≥a.\n"
    
    if failed_files:
        message += f"\n‚ùå L·ªói khi x√≥a:\n"
        for file, error in failed_files:
            message += f"‚û§ *{file}*: {error}\n"
    
    message += f"\n*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ùñ TH√îNG TIN ‚ùñ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n" \
              f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
              f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
              f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
    
    try:
        await send_simple_msg(update, context, message)
    except Exception as e:
        print(f"Error sending clearfiles response: {e}")
        message = f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú® L·ªñI ‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*\n\n" \
                  f"‚ùå L·ªói g·ª≠i th√¥ng b√°o x√≥a file: *{str(e)}*\n" \
                  f"‚è∞ Th·ªùi Gian: *{current_time}*\n" \
                  f"üëë Ch·ªß S·ªü H·ªØu: *@{CONFIG['ADMIN_USERNAME']}*\n" \
                  f"*‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ú®üåü‚ú®‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê*"
        await send_simple_msg(update, context, message)

# Button callback
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    packages = {
        "buy_1day": f"G√≥i 1 Ng√†y - *10.000ƒë*\nLi√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*",
        "buy_3day": f"G√≥i 3 Ng√†y - *30.000ƒë*\nLi√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*",
        "buy_7day": f"G√≥i 7 Ng√†y - *50.000ƒë*\nLi√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*",
        "buy_10day": f"G√≥i 10 Ng√†y - *90.000ƒë*\nLi√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*",
        "buy_30day": f"G√≥i 30 Ng√†y - *170.000ƒë*\nLi√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*",
        "vip_likes": f"*üíñ CHI TI·∫æT G√ìI LIKES*\n" \
                     f"üíé 50K / 7 ng√†y ‚Äî *700 Likes*\n" \
                     f"üíé 60K / 14 ng√†y ‚Äî *1400 Likes*\n" \
                     f"üíé 170K / 30 ng√†y ‚Äî *3000 Likes*\n" \
                     f"Li√™n h·ªá: *@{CONFIG['ADMIN_USERNAME']}*"
    }
    if query.data in packages:
        await query.edit_message_text(packages[query.data], parse_mode="Markdown")

# Main
async def main_async():
    try:
        app = Application.builder().token(CONFIG["TELEGRAM_BOT_TOKEN"]).build()
    except Exception:
        await notify_admin(None, "L·ªói kh·ªüi t·∫°o bot")
        return
    
    app.add_handler(CommandHandler("admin", admin_command))
    app.add_handler(CommandHandler("status", status_command))
    app.add_handler(CommandHandler("like", like_command))
    app.add_handler(CommandHandler("buy", buy_command))
    app.add_handler(CommandHandler("menuff", menuff_command))
    app.add_handler(CommandHandler("likeffvip", likeffvip_command))
    app.add_handler(CommandHandler("likefflai", likefflai_command))
    app.add_handler(CommandHandler("listvip", listvip_command))
    app.add_handler(CommandHandler("yes", yes_command))
    app.add_handler(CommandHandler("no", no_command))
    app.add_handler(CommandHandler("yes1", yes1_command))
    app.add_handler(CommandHandler("no1", no1_command))
    app.add_handler(CommandHandler("listgroups", listgroups_command))
    app.add_handler(CommandHandler("list_idad", list_idad_command))
    app.add_handler(CommandHandler("addadmin", add_admin_command))
    app.add_handler(CommandHandler("deladmin", deladmin_command))
    app.add_handler(CommandHandler("clearfiles", clearfiles_command))
    app.add_handler(CallbackQueryHandler(button_callback))
    
    try:
        await app.initialize()
        await app.start()
        await app.updater.start_polling(drop_pending_updates=True)
        print("‚úÖ Bot ƒë√£ s·∫µn s√†ng - G√µ /admin ƒë·ªÉ test!")
    except Exception:
        await notify_admin(app, "L·ªói kh·ªüi ƒë·ªông bot")
        return
    
    try:
        # Ch·∫°y auto buff kh·ªüi ƒë·ªông
        await perform_auto_buff(app, "KH·ªûI ƒê·ªòNG")
        # T·∫°o c√°c t√°c v·ª• b·∫•t ƒë·ªìng b·ªô
        asyncio.create_task(auto_buff_loop(app))
        asyncio.create_task(reload_vip_periodically(app))
        # Gi·ªØ bot ch·∫°y m√£i m√£i
        await asyncio.Event().wait()
    except Exception:
        await notify_admin(app, "L·ªói trong v√≤ng l·∫∑p ch√≠nh")
        await app.stop()
        await app.shutdown()

# Ch·∫°y bot
if __name__ == "__main__":
    try:
        asyncio.run(main_async())
    except KeyboardInterrupt:
        print("Bot stopped by user")
    except Exception as e:
        print(f"Error running bot: {e}")